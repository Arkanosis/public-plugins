<html>
  <head>
    <meta name="navigation" content="Website" />
    <title>Private documentation</title>
  </head>
<body> 
  <h2>Building a Wizard</h2>
  <h3>What is a wizard?</h3>
  In Ensembl, a wizard is a collection of pages that guide a user through a collection of steps to perform a specific task. For example, wizards are used in registering new users. Wizards are useful when a task requires a large amount of information to be collected that may be daunting in a single page form, or that can be easily grouped together into logical chunks. Collecting and processing biological information often requires both, and so Ensembl includes a collection of modules to facilitate the building of wizards. 
   <h3>Wizard comprise nodes</h3>
   Wizards are made up of a number of different steps, linked together to guide the user through a specific task. In Ensembl each step of this process is called a <b>node</b>. Nodes are linked together to form a wizard (see <a href="#chain">The wizard response chain</a>). In general, a single node would perform one of three functions:
   <ul>
     <li><b>Display a form:</b> for data collection and verification</li>
     <li><b>Display a message:</b> rendering a status message, response or other information to the browser in standard HTML.</li>
     <li><b>Perform a background task:</b> typically database access of some kind. Once the background task is complete, the node redirects the user to the next appropriate step in the process, and typically displays no information itself.</li>
   </ul>
   <a name="chain"></a><h3>The wizard response chain</h3>
   Nodes are arranged into a response chain, which takes the form of a directional acyclic graph. The edges of the graph indicate how a user is guided through the wizard. For example, a wizard designed to add new information to a database may have the following response chain.
    <a name="database"></a><pre style="font-size: 14px;">
        +-html node------+
        |  Instructions  |  
        +----------------+
                &darr;
        +-form node------+
        |  Data entry    |  
        +----------------+
                &darr;
        +-task node------+
        |  Database add  |  
        +----------------+
                &darr;
        +-html node------+
        |  Response      |  
        +----------------+
    </pre>
   In this wizard, a user is first presented with a set of instructions, and (typically) a 'Next' button. On clicking the button, they are taken to a form where they can enter information to insert into the database, a 'Back' button to return to the instructions, and a 'Save' button to proceed to the next stage: the task node. This node attempts to add the information from the data entry node into the database and records the response (or any other information from the database). It then forwards the user to the final response node, which displays the success (or otherwise) of the database access. 
   <h3>Creating a Wizard in Ensembl</h3>
   Wizards in Ensembl are all subclasses of the <code>EnsEMBL::Web::Wizard</code> class. Typically, the Wizard's are named after the data types which are often seen elsewhere in Ensembl: <code>EnsEMBL::Web::Wizard::Chromosome</code>, <code>EnsEMBL::Web::Feature</code>, <code>EnsEMBL::Web::Wizard::User</code>.
   <br />
   <ul>
   <h4>Wizard setup</h4>
   Each <code>Wizard</code> module contains all the information required for all possible steps in a wizard guide. Each step (ie, each node) has a name associated with it, and are defined in the <code>%all_nodes</code> hash. In addition to all nodes being defined, all form elements appearing within all nodes are also defined, in the <code>%form_fields</code>. All possible messages are also stored in the <code>Wizard</code> module, in the <code>%messages</code> hash.
   <br /><br />
    When a new wizard object is created (see <a href="#creating">Creating a wizard object</a>), an <code>_init</code> method is called on instantiation. Setting up the <code>%all_nodes</code>, <code>%form_fields</code> and <code>%messages</code> hashes (along with some other configuration options) should be done here. For example, our <a href="#database">database addition wizard</a> (for storing names and organisations) could be configured like this:
  <br /><br />
  <ul>
  <li> Form field elements:
   <code><pre>
    my %form_fields = (
      'user_id'   => {
          'type'=>'Integer',
          'label'=>'',
      },
      'email'     => {
          'type'=>'Email',
          'label'=>'Email address',
          'required'=>'yes',
      },
      'password'  => {
          'type'=>'Password',
          'label'=>'New Password',
          'required'=>'yes',
      },
      'confirm_password'  => {
          'type'=>'Password',
          'label'=>'Confirm Password',
          'required'=>'yes',
      },
      'name'      => {
          'type'=>'String',
          'label'=>'Your Name',
          'required'=>'yes',
      },
      'org'       => {
          'type'=>'String',
          'label'=>'Organisation',
      }
   );
   </pre></code>
   </li>
   <li> Node definitions:
   <code><pre>
   my %all_nodes = (
      'instructions'   => {'title' => 'Add new name wizard',
                        'page' => 1, 
      },
      'data_entry'     => {
                      'form' => 1,
                      'title' => 'Please enter your details',
                      'input_fields'  => [qw(name password email org)],
      },
      'database'      => {},
      'response'   => {'title' => 'Database response',
                        'page' => 1,
      },
   );
   </pre></code>
   </li>
   <li> Messages:
   <code><pre>
   my %message = (
     'success' => "Thank you. Your details were added to the database",
     'failure' => 'Sorry. Your request failed.',
   );
   </pre></code>
   </li>
   </ul>
   Once the new <code>Wizard</code> node definitions are in place, the actual logic for each node should to be added.
   <br />
   <h4>Adding node logic</h4>
   Each node definition is assigned a name, as the key of the <code>all_nodes</code> hash. In this example, the names would be <code>instructions</code>, <code>data_entry</code>, <code>database</code> and <code>response</code>. A method call is made when each node is processed, depending on the node's name. In this example, each node should also have a similarly named method included in the <code>Wizard</code> module. 
   <code><pre>
   package EnsEMBL::Web::Wizard:DatabaseAdd.pm;
   
   sub _init {
      ## node definitions and initialisation
      ...
   }
  
   sub instructions {
     ## empty method - output is determined by 
     ## the component
   }

   sub data_entry {
     my ($self, $object) = @_;
     my $wizard = $self->{wizard};
     my $node = 'enter_details';

     my $form = EnsEMBL::Web::Form->new($node, "/$species/$script", 'post' );

     $wizard->add_title($node, $form, $object);
     $wizard->add_widgets($node, $form, $object);
     $wizard->add_buttons($node, $form, $object);
     return $form;
   }

   sub database {
     ## database connectivity
     ...
   }

   sub response {
     ## empty method - output is determined by 
     ## the component
   } 

   1;
   </pre></code>
   See the Wizard API documentation for more information. 
   <h4>Creating a wizard object</h4>
   Once the node definitions and form elements are in place in the <code>Wizard</code> module, the wizard should be configured to be displayed for particular requests. This is done in the corresponding <code>Configuration</code> module. For example: 
   <code><pre>
   sub add {
     my $self   = shift;
     my $object = $self->{'object'};

     my $wizard = EnsEMBL::Web::Wizard::User->new($object);

     $wizard->add_nodes([qw(introduction data_entry database response)]);
     $wizard->default_node('introduction');

     $wizard->add_outgoing_edges([
          ['introduction' => 'data_entry'],
          ['data_entry' => 'database'],
          ['database' => 'response'],
     ]);

     $self->add_wizard($wizard);
     $self->wizard_panel('Add data');
   }
   </pre></code>
   <h4>Rendering wizard content</h4>
   As with other pages and panels in Ensembl, a <code>Wizard</code>'s HTML output is determined by the appropriate <code>Component</code> module. For example, the <code>EnsEMBL::Web::Component::User</code> component is responsible for displaying information relating to the <code>EnsEMBL::Web::Wizard::User</code> wizard.
   <br /><br />
   Standard HTML nodes do not perform any operations when they are displayed (reflected by an empty node method call in the <code>Wizard</code> (see <code>sub introduction</code> and <code>sub response</code> above). Their companion <code>Component</code> methods determine how these nodes are displayed:
   <ul>
   <code><pre>
   sub introduction {
     my ($panel, $object) = @_;
     my $html = "..." 
     ## Setup HTML for output
     ...
     $panel->print($html);
     return 1;
   }
   </pre></code>
   </ul>
   Form nodes can configure additional HTML, but must also setup the appropriate form for output:
   <ul>
   <code><pre>
   sub data_entry {
     my ($panel, $object) = @_;
     my $html = "..." 
     ## Setup HTML for output
     ...
     $html .= $panel->form('data_entry')->render();
     $panel->print($html);
     return 1;
   }
   </pre></code>
   </ul>
   </ul> 
  <h3>Node definitions</h3>
  Each node definition contains a number of key value pairs used to configure the node's behaviour and display. Commonly used keys are described below:
   <ul>
     <table width="80%">
       <tr><td><code>page</code></td><td>Sets the node to be an HTML page.</td></tr>
       <tr><td><code>form</code></td><td>Sets the node to be include a form.</td></tr>
       <tr><td><code>title</code></td><td>Determines the title of the form for use in <code>Component</code> rendering.</td></tr>
       <tr><td><code>input_fields</code></td><td>An array of field element names for inclusion in the node's form</td></tr>
       <tr><td><code>pass_fields</code></td><td>An array of field element names to be passed along to the next node.</td></tr>
       <tr><td><code>show_fields</code></td><td>An array of field element names for display. These have usually been passed from the previous node.</td></tr>
       <tr><td><code>button</code></td><td>The label of the button used to arrive at the node. This is displayed on the previous node's page.</td></tr>
     </table>
   </ul>

</body>
</html>
  
