<html>
  <head>
    <meta name="navigation" content="Website" />
    <title>Using and customising z-menus</title>
  </head>
<body> 
  <h2>Using and customising z-menus in Ensembl</h2>
  <h3>What are z-menus?</h3>
  In Ensembl, 'z-menus' refer to the pop up items that appear when features are clicked in the genome browser images. These items are used for navigation around the genome (zooming in, out and centering the view), and to display additional information regarding a specific feature. This page describes how to create, manage and otherwise manipulate the z-menus used in Ensembl. <br /><br />
  There are potentially many uses for z-menus in Ensembl, but regardless of the intended application, the method by which new menus are created, or existing menus are customised is the same.
  <h3>A word on asynchronicity</h3>
  Ensuring that Ensembl is as fast loading and responsive as possible is a top priority for the system developers. As the overhead of requesting and processing the information required to populate the pop up z-menus in the various Ensembl views is relatively large, it is helpful to be able to such collect this information only as it is needed by the user. This processing happens in the background (ie: asynchronously) after the main page has loaded, as and when a feature in a view is clicked. 
  <br /><br />
   The method of creating and displaying information via z-menus automatically makes used of this asychronous behaviour.
  <h3>Z-menu life cycle</h3>
  <h4>1. A simple link</h4>
  A z-menu starts life as link to a javascript function call, <code>menu</code>. When a new glyph is drawn to a <code>DrawableContainer</code> by either one of the GlyphSets in <code>Bio::EnsEMBL::GlyphSet</code> or the <code>Sanger::Graphics::Renderer::imagemap</code>, an entry is also made in the clickable image map for the resulting image which contains the information necessary to display the z-menu. Each glyph that requires a new z-menu be displayed should respond to a <code>zmenu</code> call, returning a new <code>EnsEMBL::Web::Interface::ZMenu</code> object. For example:
  <ul>
  <code><pre>
sub zmenu {
  ### Routing method
  my ($self, $gene, $transcript, $ajax) = @_; 
  if ($ajax) {
    return $self->ajax_zmenu($gene);
  } else {
    return $self->static_zmenu($gene, $transcript);
  }
}

sub ajax_zmenu {
  ### Creates a new z-menu object, and returns it.
  my ($self, $gene) = @_;
  my $zmenu = EnsEMBL::Web::Interface::ZMenu->new( (
                                     title => $gene->stable_id(),
                                     type  => 'ensembl_transcript',
                                     ident => $gene->stable_id(),
                               placeholder => 'yes'
                                      ) );
  return $zmenu;
}

sub static_zmenu {
   ### Code for synchronous menu display (slower)
   ...
}
  </pre></code>
  </ul> 
  This <code>ZMenu</code> object is then used by the imagemap renderer to generate the appropriate javascript link which will be used in the imagemap, via the <code>EnsEMBL::Web::Interface::ZMenuCollection</code> class. This class controls how the ZMenu objects are represented at the various different stages of their life cycle, and determins the protocol by which the server and browser will communicate when the <code>ZMenu</code> is populated asynchronously.<br /><br />
  The image and image map are eventually sent to the browser, where the z-menu lies dormant as a javascript link. Each feature has its own unique link which, when clicked, will display the z-menu as it stands now (ie, empty), and start the background process of populating it with content.
  <h4>2. An empty menu</h4>
  When a user clicks on a feature in the Ensembl image, a javascript call is made (<code>menu</code>). This call immediately constructs and displays the menu as it stands. The javascript can be found in <code>ajax_zmenu.js</code>. By default, a placeholder z-menu will be displayed, which informs the user that the system is loading the menu content. As soon as the menu is displayed, an asynchronous call is made to <code>populate_zmenu</code>, to (unsurprisingly), populate the menu.
  <h4>3. A populated menu</h4>
  Once the asynchronous request is sent to the server from the feature click in Ensembl in the browser, at least one new object is created based on the <code>type</code> parameter of the original <code>ZMenu</code>. For example, above a new <code>ZMenu</code> placeholder object was created with a type of <code>ensembl_transcript</code>. As such, a new <code>EnsEMBL::Web::Interface::ZMenu::ensembl_transcript</code> is created. This object has the job of retrieving and processing the necessary information to populate the (currently empty) z-menu. The class should implement these functions in the <code>populate</code> method, which is called automatically on new <code>ZMenu::</code> objects.<br /><br />
  The <code>ZMenu::ensembl_transcript</code> will be passed in sufficient information to collate the necessary content. Once it is ready, a series of <code>add</code> calls can be made to populate the menu.  For example:
  <ul>
    <li><code>add_text</code></li>
    <li><code>add_link</code></li>
    <li><code>add_html</code></li>
  </ul>
  Each method adds a new content row to the z-menu. Once the <code>populate</code> method is complete, the results are sent back to the browser, and the z-menu is populated via javascript. At this stage, the user should now be looking at the appropriate content.
  <h4>4. A closed menu</h4>
  Menus remain open once clicked and can be dragged around using the dark grey title bar, or minimised using the disclosure triangle. Clicking the 'X' will close the menu. Menus are not presently cached, so another click on the feature will reperform the asynchronous population.
  <h3>Plugins and customisation</h3>
  The z-menu procedure supports additional customisation through the Ensembl plug in system. When a menu is populated, the plugin directories are also searched for similarly named <code>ZMenu::</code> objects. These objects are passed the same parameters as other objects via the <code>populate</code> call, and can add additional content to the menu via the <code>add</code> methdos above. Existing content which may have already been added by other plugins can also be removed with the <code>remove_by_name</code> function.
  <h3>Non-asychronous behaviour</h3>
  If necessary (for debugging, or on older browsers, for example), the asynchronous nature of the z-menus can be repressed. In place of returning an empty, placeholder <code>ZMenu</code> object from the glyph, a fully populated object can be returned. This populated menu will take longer to prepare, and take longer to download, but will be displayed in its completeness when a feature is clicked in EnsEMBL. For example:
  <ul>
  <code><pre>
sub zmenu {
  ### Routing method
  my ($self, $gene, $transcript, $ajax) = @_; 
  if ($ajax) {
    return $self->ajax_zmenu($gene);
  } else {
    return $self->static_zmenu($gene, $transcript);
  }
}

sub ajax_zmenu {
  ### Code for asynchronous menu display (faster)
  ...
}

sub static_zmenu {
  my ($self, $gene) = @_;
  my $zmenu = EnsEMBL::Web::Interface::ZMenu->new( (
                                     title => $gene->stable_id(),
                                     type  => 'ensembl_transcript',
                                     ident => $gene->stable_id(),
                               placeholder => 'no'
                                      ) );
  $zmenu->add_text('text1', 'ID: ' . $gene->stable_id() );
  $zmenu->add_link((name => 'link1', 
                    text => 'More: ' . $gene->stable_id(), 
                     url => 'http://www.ensembl.org' ) );
  return $zmenu;
}
  </pre></code>
  </ul> 
</body>
</html>
  
