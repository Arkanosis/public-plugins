<html>
  <head>
    <meta name="navigation" content="Website" />
    <title>Private documentation</title>
  </head>
<body> 
  <h2>Page building: Dynamic pages</h2>
  <h3>Preamble</h3>
  There are two types of pages in Ensembl: static and dynamic. This page introduces the process by which the data objects and page elements of a dynamic page are created and displayed back to the user after a request to Apache. Other pages discuss the <a href="apache_loop.html">Apache request loop</a>, and the <a href="configuration.html">configuration and session management</a> in Ensembl.
  <h3>Script handler calls</h3>
  The Trans handler in <a href="apache_loop.html">the loop</a> interprets the requested URL received from the browser. The following locations are searched for dynamic content scripts, in order of preference:
  <ul>
    <li>Plug in directories</li>
    <li><code>ENSEMBL_ROOT/perl/default</code></li>
    <li><code>ENSEMBL_ROOT/perl/common</code></li>
    <li><code>ENSEMBL_ROOT/perl/multi</code></li>
  </ul>
  If a dynamic script is found, it's location is sent to the Apache script handler which effectively runs the script via Perl. Ensembl uses <a href="http://perl.apache.org/">mod_perl</a>, which embeds Perl into Apache for <a href="http://perl.apache <.org/start/index.html">performance and extensibility</a>.<br /><br />
  The dynamic page scripts can contain any valid Perl calls, however, in Ensembl, they are usually used to instantiate a new <code>EnsEMBL::Web::Document::WebPage</code> object. This class of object is responsible for managing the process of building a new response (usually in HTML) which is returned to the user.

  <h3>Building a page with Document::WebPage</h3>
  <code>EnsEMBL::Web::Document::WebPage</code> (or simply <code>WebPage</code> for brevity) is used by Ensembl to construct the web pages viewed by users. It is responsible for controlling the process of retrieving all required data from the Ensembl databases, formatting that data, generating images where necessary and collating all information together to be displayed to the user.<br /><br /> 
  Fortunately, much of this complexity is compartmentalised into individual Perl modules (namely the <code>Factory</code>, <code>Component</code>, <code>Configuration</code> and <code>Object</code> families of classes) which <code>WebPage</code> manages and manipulates to create a reponse page. As such, a new web page can be created in Ensembl with a very simple script. For example, a new GeneView page is created with:
<code><pre style="padding: 15px; font-size: 14px;">
package geneview;

use EnsEMBL::Web::Document::WebPage;
simple_with_redirect( 'Gene' );
</pre></code>

<p> (<code>simple_with_redirect</code> create an object of type "Gene")</p>

   <h3><a name="default_responses"></a>Renderers, output types and document types</h3> 
   Before looking at the process by which a new page is constructed, configured and displayed, it is worth considering three important parts of the <code>WebPage</code> machinery:
  <ul>
  <h4>Renderers</h4>
      <code>WebPage</code> renderers are of the <code>EnsEMBL::Web::Document::Renderer</code> family of classes and dictate the destination of any output generated by <code>WebPage</code> and its components. The default, <code>EnsEMBL::Web::Document::Renderer::Apache</code>, sends the output as a response to a request from a browser, via Apache. Renderers usually accept output via one or more <code>print</code> methods. (Other example <code>EnsEMBL::Web::Document::Renderer::GZfile</code>).
  <h4>Output types</h4>
  Output types determine the format of the response set to a final destination by the <code>Renderer</code>. The default is a particular flavour of HTML.
  <h4>Document types</h4>
  <code>WebPage</code> uses an object from the <code>EnsEMBL::Web::Document</code> family to setup and configure the content of the output. This is usually (but not necessarily) coupled with an output type. The default for dynamic pages is (unsurprisingly) <code>EnsEMBL::Web::Document::Dynamic</code>. Other examples include <code>EnsEMBL::Web::Document::Pop-Up</code> and <code>EnsEMBL::Web::Document::Common</code>.  (<code>Common</code> has the components which are needed for the static, dynamic and pop-up pages and <code>EnsEMBL::Web::Document::Dynamic</code> inherits from this).
  </ul>
  The default values used by <code>WebPage</code> generate an HTML web page response to Apache. However, <a href="#other_responses">other response types are available</a>.

  <h3>The WebPage build pipeline</h3>
  As seen above, a new GeneView page is constructed with a call to <code>WebPage</code>'s <code>simple_with_redirect()</code>. This starts a production pipeline made up of the following stages: 
<code><pre style="padding: 15px; font-size: 14px;">
  START
    &darr;
  Initialise output 
    &darr;
  Setup common output components
    &darr;
  Retrieve data
    &darr;
  Setup data specific output components
    &darr;
  Collate and render
    &darr;
  Delivery
</pre></code>
  GeneView produces an HTML page, delivered to a user's browser via Apache. Using this as an example, let's look at each stage:
  <ul>
  <h4>START</h4>
  The pipeline starts with a call from the view script (e.g. <code>perl/default/geneview</code>) to <code>WebPage::simple_with_redirect()</code>. A single parameter is provided which informs <code>WebPage</code> of the type of page to create. In effect, this parameter (<code>Gene</code>, in the case of GeneView) configures which data objects to create, and how they are to be configured and collated for the final deliverable content.
  <h4>Initialise output</h4>
  <code>WebPage</code> then initialises the various components necessary to produce output: the <a href="default_responses">renderer (e.g. Apache), the output type (e.g. HTML) and the document type (e.g. Dynamic)</a>. In addition, a <code>SpeciesDefs</code> object is created. This object plays an important part in configuring Ensembl, and is made available to all other layout and data objects created by <code>WebPage</code>. It is discussed in more detail on the <a href="configuration.html">Configuration and sessions page</a>. A timer is also set up for debugging and profiling.
   <h4>Setup common output components</h4>
   Almost all types of output (especially HTML) require a certain amount of common content.  These output components are independent of the data requested, and include items such as:<br /><br />
   <ul>
   <li>The XML DOCTYPE statement</li>
   <li>Common headers</li>
   <li>HTML meta tags</li>
   <li>Stylesheet includes</li>
   <li>Javascript includes</li>
   <li>Common look and feel elements</li>
   <li>Common menus</li>
   <li>Copyright notices</li>
   </ul><br />
   For GeneView, as it is a dynamic HTML page, the <code>WebPage::new</code> calls  <code>EnsEMBL::Web::Document::Dynamic::_initialize_HTML</code> which by default contains all these and more.
 
The templates for each section of the webpage are in an ordered array which is passed to the <code>add_body_elements </code> function.  The common output components can be expanded, edited or removed using the Ensembl plugin system <a name="origin_plugins"></a><a href="#footnote_plugins"><sup>1</sup></a>.
  <br /><br />
  At the end of this stage, an output template has been established based on a collection of components, optionally configured and tweaked by the plugins. It has not yet been constructed (for example, the HTML has not yet been collated ready for delivery), but is ready to be populated with additional data content.
  <h4>Retrieve data</h4>
  The retrieval of data in Ensembl is also compartmentalised and distributed between a collection of Perl modules. The <code>EnsEMBL::Web::Document::Dynamic</code> document type object is attached to the <code>WebPage</code>'s <code>page</code> parameter for easy access of other page components, and it is the <code>WebPage</code> that proceeds to retrieve data from the Ensembl databases.  
  <br /><br />
  The methods by which data is retrieved from an EnsEMBL database is separated from the methods by which that data is rendered and delivered back from the user. In effect, the classes and methods that retrieve and represent the data can be reused in other projects relatively easily. When a new <code>WebPage</code> is created, a new object of the <code>Factory</code> family is created. This <code>Factory</code> is responsible for creating the appropriate data objects for the page<a name="origin_factory"></a><a href="#footnote_factory"><sup>2</sup></a>, and is configured using the original page type provided at the start of the pipeline (for example, 'Gene'). The CGI object containing the parameters passed to the page in the URL is passed along to the <code>Factory</code> allowing it to retrieve and configure the necessary data objects for display.<br /><br />
  Once the data objects have been retrieved, additional data-specific components are added to the output. The actual data output will be added in the <a href="#collate">Collate and Render</a> stage.
  <h4>Setup data specific output components</h4>
  At this stage, additional output components which display data are configured. For example, menu items can be added or removed, or the mast head for a page can be updated to reflect the data within it.
  <h4><a name="collate"></a>Collate and render</h4>
  Now that all the data and layout components have been retrieved and configured, the page output is collated. Any images are drawn (and optionally cached), and the output is rendered for delivery. 
  <h4>Delivery</h4>
  Once rendered, the output is delivered to a final destination. In most cases this is served back to the user's browser via Apache, but it could also be sent to a gzip file for archival, to another server as a response to a web service, or returned over an alternate transport protocol for communication between processes.
  </ul>
  <h3><a name="other_responses"></a>Building other responses with Document::WebPage</h3>
  <code>EnsEMBL::Web::Document::WebPage</code> is something of a misnomer. Whilst a standard plain text HTML response is commonly used by Ensembl, <code>EnsEMBL::Web::Document::WebPage</code> can return data in a number of other formats by replacing the default <a href="#default_responses">renderer, output type and document type</a>. 
  <h3>Footnotes</h3>
  <ul>
  <li><a name="footnote_plugins"></a>1.
   The document type for a page configures the appropriate set of common output components (such as those listed above) based on the output type (for example, GeneView defaults to calling  <code>_initialize_HTML</code>). Once a default set of components has been established, the installed plugins are queried for updates to that default set. Any plugins wishing to extend the default output components should implement one or both of:
  <br /><br />
  <ul>
    <li><code>MyPlugin::modules::EnsEMBL::MyPlugin::Document::Configure::common_page_elements()</code></li>
    <li><code>MyPlugin::modules::EnsEMBL::MyPlugin::Document::Configure::dynamic_page_elements()</code></li>
  </ul>
  <br />
  These methods can then make use of such calls as <code>add_body_element()</code>, <code>add_body_element_after()</code> and <code>replace_body_element()</code>. Check the <i>e!</i> doc for <code>EnsEMBL::Web::Document::Page</code> for more information.
 <a href="#origin_plugins">&uarr;</a></li>
 </ul><br />
 <ul>
  <li><a name="footnote_factory"></a>2.
  In effect, the <code>Factory</code> created is an <code>EnsEMBL::Web::Proxy::Factory</code>, which in turn creates the correct <code>Factory</code> type, determined by the original page type provided at the start of the pipeline. For example, in the case of GeneView, an <code>EnsEMBL::Web::Factory::Gene</code> would be created. This is also so the <code>Factory</code> can cope with the plug-in code looping through each <code>Factory</code> in the plug-ins directory.  <br /><br />
  This <code>Factory</code> then creates the appropriate <code>EnsEMBL::Web::Object::Gene</code>, <code>EnsEMBL::Web::Configuration::Gene</code> and <code>EnsEMBL::Web::Component::Gene</code> objects, which provide data, configuration and layout view information respectively.
  <a href="#origin_factory">&uarr;</a></li>
  </ul>
</body>
</html>
  
