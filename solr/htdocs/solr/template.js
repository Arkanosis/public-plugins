// Generated by CoffeeScript 1.5.0
(function() {
  var Assembly, Component, Directive, Part, Registry, next_class_id_idx;

  Directive = (function() {

    function Directive(selector, value, loopvars) {
      var k, m, sk, sv, v, _ref, _ref1;
      this.selector = selector;
      this.loopvars = loopvars;
      if ((_ref = this.loopvars) == null) {
        this.loopvars = [];
      }
      if (typeof value === 'string') {
        this.value = value.split('.');
      } else if ($.isFunction(value)) {
        this.value = value;
      } else {
        for (k in value) {
          v = value[k];
          m = /^(.*)\<\-(.*)$/g.exec(k);
          if (m.length) {
            _ref1 = [m[1], m[2].split(".")], this.loopvar = _ref1[0], this.list = _ref1[1];
            this.subs = (function() {
              var _results;
              _results = [];
              for (sk in v) {
                sv = v[sk];
                _results.push(new Directive(sk, sv, this.loopvars.concat([this.loopvar])));
              }
              return _results;
            }).call(this);
          }
        }
      }
    }

    Directive.prototype._accessor = function(value, model_context) {
      return ($.inArray(value[0], this.loopvars) !== -1 ? value : model_context.concat(value)).join('.');
    };

    Directive.prototype.emit = function(model_context, view_context) {
      var ik, inner, k, real, sub, v, value, _i, _len, _ref, _ref1;
      if (this.loopvar) {
        inner = {};
        ik = this.loopvar + "<-" + this._accessor(this.list, model_context);
        value = {};
        value[ik] = {};
        _ref = this.subs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          sub = _ref[_i];
          _ref1 = sub.emit(model_context, []), k = _ref1[0], v = _ref1[1];
          value[ik][k] = v;
        }
      } else if ($.isArray(this.value)) {
        value = this._accessor(this.value, model_context);
      } else {
        real = this.value;
        value = function(e) {
          var context, f, x, _j, _len1;
          context = e.context;
          for (_j = 0, _len1 = model_context.length; _j < _len1; _j++) {
            x = model_context[_j];
            context = context[x];
          }
          f = $.extend({}, e, {
            context: context
          });
          return real.call(this, f);
        };
      }
      return [view_context.concat([this.selector]).join(' '), value];
    };

    return Directive;

  })();

  Component = (function() {

    function Component(registry, spec, name) {
      var k, v, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this.registry = registry;
      this.spec = spec;
      this.name = name;
      this.template = $($.trim((_ref = spec.template) != null ? _ref : "<div></div>"));
      this.directives = (_ref1 = this._directives_from_spec(this.spec)) != null ? _ref1 : {};
      this.submap = (_ref2 = this.spec.subtemplates) != null ? _ref2 : {};
      this.sockets = {};
      _ref4 = (_ref3 = this.spec.sockets) != null ? _ref3 : {};
      for (k in _ref4) {
        v = _ref4[k];
        this.sockets[v] = k;
      }
      this.config = (_ref5 = this.spec.config) != null ? _ref5 : {};
      this.postproc = (_ref6 = this.spec.postproc) != null ? _ref6 : function(el, data) {};
      this.decorate = (_ref7 = this.spec.decorate) != null ? _ref7 : {};
      this["extends"] = this.spec["extends"];
      this.fixes = this.spec.fixes;
      this.more_fixes = this.spec.more_fixes;
    }

    Component.prototype.resolved = function() {
      var k, parent, v, _ref;
      if (this["extends"] != null) {
        parent = this.registry.get(this["extends"]);
        if (parent != null) {
          _ref = parent.spec;
          for (k in _ref) {
            v = _ref[k];
            if (this.spec[k] == null) {
              this.spec[k] = v;
            }
          }
          this.spec["super"] = parent.spec;
        }
        delete this["extends"];
        return new Component(this.registry, this.spec, this.name);
      } else {
        return this;
      }
    };

    Component.prototype.run_preproc = function(data) {
      var spec, _ref;
      spec = this.spec;
      if (this.spec.preproc != null) {
        _ref = this.spec.preproc(this.spec, data), spec = _ref[0], data = _ref[1];
      }
      return [new Component(this.registry, spec, this.name), data];
    };

    Component.prototype.emit_directives = function(model_context, view_context) {
      var d, k, out, v, _i, _len, _ref, _ref1;
      out = {};
      _ref = this.directives;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        _ref1 = d.emit(model_context, view_context), k = _ref1[0], v = _ref1[1];
        out[k] = v;
      }
      return out;
    };

    Component.prototype._directives_from_spec = function(spec) {
      var k, out, v, _ref;
      out = [];
      _ref = spec.directives;
      for (k in _ref) {
        v = _ref[k];
        out.push(new Directive(k, v));
      }
      return out;
    };

    Component.prototype.get_config = function(key, data) {
      if ($.isFunction(this.config[key])) {
        return this.config[key](data);
      } else {
        return this.config[key];
      }
    };

    Component.prototype.submap_get = function() {
      return this.submap;
    };

    Component.prototype.decorate_get = function() {
      return this.decorate;
    };

    Component.prototype.postproc_get = function() {
      return this.postproc;
    };

    Component.prototype.has_socket = function(s) {
      return this.sockets[s] != null;
    };

    Component.prototype.get_socket = function(s) {
      return this.sockets[s];
    };

    Component.prototype.get_fixes = function() {
      return this.fixes;
    };

    Component.prototype.get_more_fixes = function() {
      var k, _i, _len, _ref, _ref1, _results;
      _ref1 = (_ref = this.more_fixes) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        _results.push(this.registry.get(k));
      }
      return _results;
    };

    Component.prototype.emit_template = function(klass) {
      var out;
      out = this.template.clone();
      out.addClass(klass);
      return out;
    };

    Component.prototype.get_parent = function() {
      if (this["extends"] != null) {
        this.parent = this.registry.get(this["extends"]);
        this["extends"] = void 0;
      }
      return this.parent;
    };

    Component.prototype.make_part = function(assembly, model_context, base_vc, sub_vc, parent) {
      return new Part(assembly, this, model_context, base_vc, sub_vc, parent);
    };

    Component.prototype.get_all_subs = function(_seen) {
      var k, out, t, v, _i, _len, _ref;
      if (_seen == null) {
        _seen = {};
      }
      out = [];
      _ref = this.submap;
      for (k in _ref) {
        v = _ref[k];
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          t = v[_i];
          if (!_seen[t.template]) {
            out.concat(this.registry.get(t.template).get_all_subs(_seen));
          }
        }
      }
      out.push(this);
      _seen[this.name] = 1;
      return out;
    };

    return Component;

  })();

  next_class_id_idx = 1;

  Part = (function() {

    function Part(assembly, component, model_context, base_vc, sub_vc, parent) {
      var k, s, submap, v, _i, _len;
      this.assembly = assembly;
      this.component = component;
      this.model_context = model_context;
      this.sub_vc = sub_vc;
      this.parent = parent;
      this.children = [];
      if (this.parent != null) {
        this.parent.children.push(this);
      }
      this.klass = "__tmplcl__" + (next_class_id_idx += 1);
      this.view_context = base_vc.concat(this.sub_vc);
      submap = this.component.submap_get();
      this.subs = [];
      for (k in submap) {
        v = submap[k];
        if (!$.isArray(v)) {
          v = [v];
        }
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          s = v[_i];
          this.add_subtemplate(k, s);
        }
      }
    }

    Part.prototype.find_sockets_in_subtree = function(socket, ret) {
      var c, _i, _len, _ref, _results;
      if (this.component.has_socket(socket)) {
        ret.push([this, this.component.get_socket(socket)]);
      }
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.find_sockets_in_subtree(socket, ret));
      }
      return _results;
    };

    Part.prototype.find_sockets = function(socket, ret) {
      if (socket != null) {
        if (this.parent) {
          this.parent.find_sockets(socket, ret);
        } else {
          this.find_sockets_in_subtree(socket, ret);
        }
      }
      return [];
    };

    Part.prototype.add_subtemplate = function(k, v) {
      var dest_part, dest_sel, plug, sockets, sub_comp, sub_mc, _i, _len, _ref, _results;
      if (k.length && k.charAt(0) === '^') {
        k = k.substring(1);
        plug = k;
      }
      if (typeof v === 'string') {
        v = {
          template: v,
          data: v
        };
      }
      sockets = [];
      this.find_sockets(plug, sockets);
      if (sockets.length === 0) {
        sockets.push([this, k]);
      }
      _results = [];
      for (_i = 0, _len = sockets.length; _i < _len; _i++) {
        _ref = sockets[_i], dest_part = _ref[0], dest_sel = _ref[1];
        dest_sel = dest_sel.split(' ');
        if (v.data !== '') {
          sub_mc = this.model_context.concat(v.data.split('.'));
        } else {
          sub_mc = this.model_context;
        }
        sub_comp = this.assembly.registry_get(v.template, sub_mc);
        _results.push(dest_part.subs.push(sub_comp.make_part(this.assembly, sub_mc, dest_part.view_context, dest_sel, dest_part)));
      }
      return _results;
    };

    Part.prototype.emit_directives = function() {
      var a, b, dirs, s, _i, _len, _ref, _ref1;
      dirs = this.component.emit_directives(this.model_context, ["." + this.klass]);
      _ref = this.subs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _ref1 = s.emit_directives();
        for (a in _ref1) {
          b = _ref1[a];
          dirs[a] = b;
        }
      }
      return dirs;
    };

    Part.prototype.emit_template = function() {
      var s, template, _i, _len, _ref;
      template = this.component.emit_template(this.klass);
      _ref = this.subs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        $(s.sub_vc.join(' '), template).append(s.emit_template());
      }
      return template;
    };

    Part.prototype.run_postproc = function(el, data) {
      var fun, k, s, sel, sub_data, sub_el, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref = this.subs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        s.run_postproc(el, data);
      }
      sub_data = data;
      _ref1 = this.model_context;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        k = _ref1[_j];
        sub_data = sub_data[k];
      }
      sub_el = el;
      if (this.sub_vc.length) {
        sub_el = $('.' + this.klass, el);
      }
      _ref2 = this.component.decorate_get();
      for (sel in _ref2) {
        fun = _ref2[sel];
        fun.call(this, $(sel, sub_el), sub_data);
      }
      return this.component.postproc_get().call(this, sub_el, sub_data);
    };

    return Part;

  })();

  Assembly = (function() {

    function Assembly(registry, name, data) {
      this.registry = registry;
      this.name = name;
      this.data = data;
    }

    Assembly.prototype.get_fixes = function(type, comp) {
      var c, f, fixes, sub, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      fixes = [];
      _ref = comp.get_all_subs();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sub = _ref[_i];
        f = (_ref1 = sub.get_fixes()) != null ? _ref1[type] : void 0;
        if (f != null) {
          fixes = fixes.concat(f);
        }
        _ref2 = comp.get_more_fixes();
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          fixes = fixes.concat(this.get_fixes(type, c));
        }
      }
      return fixes;
    };

    Assembly.prototype.run_fixes = function(comp, data, trigger) {
      var f, fixes, k, r, tp2_out, tp2_row_out, v, _i, _j, _len, _len1, _ref;
      data.tp2 = new TextProc2();
      data.tp2_row = new TextProc2();
      fixes = this.get_fixes(trigger != null ? trigger : 'global', comp);
      for (_i = 0, _len = fixes.length; _i < _len; _i++) {
        f = fixes[_i];
        f.call(this, data);
      }
      if (data.table_row != null) {
        _ref = data.table_row;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          r = _ref[_j];
          tp2_row_out = data.tp2_row.run(r.cols);
          for (k in tp2_row_out) {
            v = tp2_row_out[k];
            r[k] = v;
          }
          if (r.cols != null) {
            for (k in tp2_row_out) {
              v = tp2_row_out[k];
              r.cols[k] = v;
            }
          }
        }
      }
      tp2_out = data.tp2.run(data);
      for (k in tp2_out) {
        v = tp2_out[k];
        data[k] = v;
      }
      if (data.cols != null) {
        for (k in tp2_out) {
          v = tp2_out[k];
          data.cols[k] = v;
        }
      }
      return data;
    };

    Assembly.prototype.generate = function(attach) {
      var all_subs, out, root_comp, root_part, template;
      root_comp = this.registry_get(this.name, []);
      this.data = this.run_fixes(root_comp, this.data);
      all_subs = root_comp.get_all_subs();
      root_part = root_comp.make_part(this, [], [], [], void 0);
      template = root_part.emit_template();
      template = template.wrap("<div></div>").parent();
      out = template.render(this.data, root_part.emit_directives());
      if (attach != null) {
        attach(out);
      }
      root_part.run_postproc(out, this.data);
      return out;
    };

    Assembly.prototype._read = function(path) {
      var data, k, _i, _len, _ref;
      data = this.data;
      for (_i = 0, _len = path.length; _i < _len; _i++) {
        k = path[_i];
        data = (_ref = data != null ? data[k] : void 0) != null ? _ref : void 0;
      }
      return data;
    };

    Assembly.prototype._write = function(path, value) {
      var data;
      if (path.length) {
        data = this._read(path.slice(0, path.length - 1));
        if (data != null) {
          return data[path[path.length - 1]] = value;
        }
      } else {
        return this.data = value;
      }
    };

    Assembly.prototype.registry_get = function(name, model_context) {
      var data, spec, _ref;
      data = this._read(model_context);
      _ref = this.registry.get(name).run_preproc(data), spec = _ref[0], data = _ref[1];
      this._write(model_context, data);
      return spec;
    };

    return Assembly;

  })();

  Registry = (function() {

    function Registry(sets) {
      this.registry = {};
      this.register_sets(sets);
    }

    Registry.prototype.register_sets = function(sets) {
      var s, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sets.length; _i < _len; _i++) {
        s = sets[_i];
        _results.push(this.register_all(s));
      }
      return _results;
    };

    Registry.prototype.register_all = function(specs) {
      var k, v, _results;
      _results = [];
      for (k in specs) {
        v = specs[k];
        _results.push(this.register(k, v));
      }
      return _results;
    };

    Registry.prototype.register = function(name, spec) {
      return this.registry[name] = new Component(this, spec, name);
    };

    Registry.prototype.get = function(name) {
      if (this.registry[name] != null) {
        this.registry[name] = this.registry[name].resolved();
      }
      return this.registry[name];
    };

    Registry.prototype.generate = function(name, data, attach) {
      var a;
      a = new Assembly(this, name, data);
      return a.generate(attach);
    };

    Registry.prototype.config = function(name, key, data) {
      return this.get(name).get_config(key, data);
    };

    return Registry;

  })();

  window.Templates = Registry;

}).call(this);
