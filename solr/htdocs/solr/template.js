// Generated by CoffeeScript 2.3.1
(function() {
  // Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
  // Copyright [2016-2018] EMBL-European Bioinformatics Institute

  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at

  //     http://www.apache.org/licenses/LICENSE-2.0

  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  var Assembly, Component, Directive, Part, Registry, next_class_id_idx;

  Directive = class Directive {
    constructor(selector, value, loopvars) {
      var k, m, sk, sv, v;
      this.selector = selector;
      this.loopvars = loopvars;
      if (this.loopvars == null) {
        this.loopvars = [];
      }
      if (typeof value === 'string') {
        this.value = value.split('.');
      } else if ($.isFunction(value)) {
        this.value = value;
      } else {
        for (k in value) {
          v = value[k];
          m = /^(.*)\<\-(.*)$/g.exec(k);
          if (m.length) {
            [this.loopvar, this.list] = [m[1], m[2].split(".")];
            this.subs = (function() {
              var results;
              results = [];
              for (sk in v) {
                sv = v[sk];
                results.push(new Directive(sk, sv, this.loopvars.concat([this.loopvar])));
              }
              return results;
            }).call(this);
          }
        }
      }
    }

    _accessor(value, model_context) {
      return ($.inArray(value[0], this.loopvars) !== -1 ? value : model_context.concat(value)).join('.');
    }

    emit(model_context, view_context) {
      var i, ik, inner, k, len, real, ref, sub, v, value;
      if (this.loopvar) {
        inner = {};
        ik = this.loopvar + "<-" + this._accessor(this.list, model_context);
        value = {};
        value[ik] = {};
        ref = this.subs;
        for (i = 0, len = ref.length; i < len; i++) {
          sub = ref[i];
          [k, v] = sub.emit(model_context, []);
          value[ik][k] = v;
        }
      } else if ($.isArray(this.value)) {
        value = this._accessor(this.value, model_context);
      } else {
        real = this.value;
        value = function(e) {
          var context, f, j, len1, x;
          context = e.context;
          for (j = 0, len1 = model_context.length; j < len1; j++) {
            x = model_context[j];
            context = context[x];
          }
          f = $.extend({}, e, {context});
          return real.call(this, f);
        };
      }
      return [view_context.concat([this.selector]).join(' '), value];
    }

  };

  Component = class Component {
    constructor(registry, spec1, name1) {
      var k, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, v;
      this.registry = registry;
      this.spec = spec1;
      this.name = name1;
      this.template = $($.trim((ref = this.spec.template) != null ? ref : "<div></div>"));
      this.directives = (ref1 = this._directives_from_spec(this.spec)) != null ? ref1 : {};
      this.submap = (ref2 = this.spec.subtemplates) != null ? ref2 : {};
      this.sockets = {};
      ref4 = (ref3 = this.spec.sockets) != null ? ref3 : {};
      for (k in ref4) {
        v = ref4[k];
        this.sockets[v] = k;
      }
      this.config = (ref5 = this.spec.config) != null ? ref5 : {};
      this.postproc = (ref6 = this.spec.postproc) != null ? ref6 : function(el, data) {};
      this.decorate = (ref7 = this.spec.decorate) != null ? ref7 : {};
      this.extends = this.spec.extends;
      this.fixes = this.spec.fixes;
      this.more_fixes = this.spec.more_fixes;
    }

    resolved() {
      var k, parent, ref, v;
      if (this.extends != null) {
        parent = this.registry.get(this.extends);
        if (parent != null) {
          ref = parent.spec;
          for (k in ref) {
            v = ref[k];
            if (this.spec[k] == null) {
              this.spec[k] = v;
            }
          }
          this.spec.super = parent.spec;
        }
        delete this.extends;
        return new Component(this.registry, this.spec, this.name);
      } else {
        return this;
      }
    }

    run_preproc(data) {
      var spec;
      spec = this.spec;
      if (this.spec.preproc != null) {
        [spec, data] = this.spec.preproc(this.spec, data);
      }
      return [new Component(this.registry, spec, this.name), data];
    }

    emit_directives(model_context, view_context) {
      var d, i, k, len, out, ref, v;
      out = {};
      ref = this.directives;
      for (i = 0, len = ref.length; i < len; i++) {
        d = ref[i];
        [k, v] = d.emit(model_context, view_context);
        out[k] = v;
      }
      return out;
    }

    _directives_from_spec(spec) {
      var k, out, ref, v;
      out = [];
      ref = spec.directives;
      for (k in ref) {
        v = ref[k];
        out.push(new Directive(k, v));
      }
      return out;
    }

    get_config(key, data) {
      if ($.isFunction(this.config[key])) {
        return this.config[key](data);
      } else {
        return this.config[key];
      }
    }

    submap_get() {
      return this.submap;
    }

    decorate_get() {
      return this.decorate;
    }

    postproc_get() {
      return this.postproc;
    }

    has_socket(s) {
      return this.sockets[s] != null;
    }

    get_socket(s) {
      return this.sockets[s];
    }

    get_fixes() {
      return this.fixes;
    }

    get_more_fixes() {
      var i, k, len, ref, ref1, results;
      ref1 = (ref = this.more_fixes) != null ? ref : [];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        k = ref1[i];
        results.push(this.registry.get(k));
      }
      return results;
    }

    emit_template(klass) {
      var out;
      out = this.template.clone();
      out.addClass(klass);
      return out;
    }

    get_parent() {
      if (this.extends != null) {
        this.parent = this.registry.get(this.extends);
        this.extends = void 0;
      }
      return this.parent;
    }

    make_part(assembly, model_context, base_vc, sub_vc, parent) {
      return new Part(assembly, this, model_context, base_vc, sub_vc, parent);
    }

    get_all_subs(_seen) {
      var i, k, len, out, ref, t, v;
      if (_seen == null) {
        _seen = {};
      }
      out = [];
      ref = this.submap;
      for (k in ref) {
        v = ref[k];
        for (i = 0, len = v.length; i < len; i++) {
          t = v[i];
          if (!_seen[t.template]) {
            out.concat(this.registry.get(t.template).get_all_subs(_seen));
          }
        }
      }
      out.push(this);
      _seen[this.name] = 1;
      return out;
    }

  };

  next_class_id_idx = 1;

  Part = class Part {
    constructor(assembly1, component, model_context1, base_vc, sub_vc1, parent1) {
      var i, k, len, s, submap, v;
      this.assembly = assembly1;
      this.component = component;
      this.model_context = model_context1;
      this.sub_vc = sub_vc1;
      this.parent = parent1;
      this.children = [];
      if (this.parent != null) {
        this.parent.children.push(this);
      }
      this.klass = `__tmplcl__${(next_class_id_idx += 1)}`;
      this.view_context = base_vc.concat(this.sub_vc);
      submap = this.component.submap_get();
      this.subs = [];
      for (k in submap) {
        v = submap[k];
        if (!$.isArray(v)) {
          v = [v];
        }
        for (i = 0, len = v.length; i < len; i++) {
          s = v[i];
          this.add_subtemplate(k, s);
        }
      }
    }

    find_sockets_in_subtree(socket, ret) {
      var c, i, len, ref, results;
      if (this.component.has_socket(socket)) {
        ret.push([this, this.component.get_socket(socket)]);
      }
      ref = this.children;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        results.push(c.find_sockets_in_subtree(socket, ret));
      }
      return results;
    }

    find_sockets(socket, ret) {
      if (socket != null) {
        if (this.parent) {
          this.parent.find_sockets(socket, ret);
        } else {
          this.find_sockets_in_subtree(socket, ret);
        }
      }
      return [];
    }

    add_subtemplate(k, v) {
      var dest_part, dest_sel, i, len, plug, results, sockets, sub_comp, sub_mc;
      if (k.length && k.charAt(0) === '^') {
        k = k.substring(1);
        plug = k;
      }
      if (typeof v === 'string') {
        v = {
          template: v,
          data: v
        };
      }
      sockets = [];
      this.find_sockets(plug, sockets);
      if (sockets.length === 0) {
        sockets.push([this, k]);
      }
      results = [];
      for (i = 0, len = sockets.length; i < len; i++) {
        [dest_part, dest_sel] = sockets[i];
        dest_sel = dest_sel.split(' ');
        if (v.data !== '') {
          sub_mc = this.model_context.concat(v.data.split('.'));
        } else {
          sub_mc = this.model_context;
        }
        sub_comp = this.assembly.registry_get(v.template, sub_mc);
        results.push(dest_part.subs.push(sub_comp.make_part(this.assembly, sub_mc, dest_part.view_context, dest_sel, dest_part)));
      }
      return results;
    }

    emit_directives() {
      var a, b, dirs, i, len, ref, ref1, s;
      dirs = this.component.emit_directives(this.model_context, ["." + this.klass]);
      ref = this.subs;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        ref1 = s.emit_directives();
        for (a in ref1) {
          b = ref1[a];
          dirs[a] = b;
        }
      }
      return dirs;
    }

    emit_template() {
      var i, len, ref, s, template;
      template = this.component.emit_template(this.klass);
      ref = this.subs;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        $(s.sub_vc.join(' '), template).append(s.emit_template());
      }
      return template;
    }

    run_postproc(el, data) {
      var fun, i, j, k, len, len1, ref, ref1, ref2, s, sel, sub_data, sub_el;
      ref = this.subs;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        s.run_postproc(el, data);
      }
      sub_data = data;
      ref1 = this.model_context;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        k = ref1[j];
        sub_data = sub_data[k];
      }
      sub_el = el;
      if (this.sub_vc.length) {
        sub_el = $('.' + this.klass, el);
      }
      ref2 = this.component.decorate_get();
      for (sel in ref2) {
        fun = ref2[sel];
        fun.call(this, $(sel, sub_el), sub_data);
      }
      return this.component.postproc_get().call(this, sub_el, sub_data);
    }

  };

  Assembly = class Assembly {
    constructor(registry, name1, data1) {
      this.registry = registry;
      this.name = name1;
      this.data = data1;
    }

    get_fixes(type, comp) {
      var c, f, fixes, i, j, len, len1, ref, ref1, ref2, sub;
      fixes = [];
      ref = comp.get_all_subs();
      for (i = 0, len = ref.length; i < len; i++) {
        sub = ref[i];
        f = (ref1 = sub.get_fixes()) != null ? ref1[type] : void 0;
        if (f != null) {
          fixes = fixes.concat(f);
        }
        ref2 = comp.get_more_fixes();
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          c = ref2[j];
          fixes = fixes.concat(this.get_fixes(type, c));
        }
      }
      return fixes;
    }

    run_fixes(comp, data, trigger) {
      var f, fixes, i, j, k, len, len1, r, ref, tp2_out, tp2_row_out, v;
      data.tp2 = new TextProc2();
      data.tp2_row = new TextProc2();
      fixes = this.get_fixes(trigger != null ? trigger : 'global', comp);
      for (i = 0, len = fixes.length; i < len; i++) {
        f = fixes[i];
        f.call(this, data);
      }
      // XXX
      if (data.table_row != null) {
        ref = data.table_row;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          r = ref[j];
          tp2_row_out = data.tp2_row.run(r.cols);
          for (k in tp2_row_out) {
            v = tp2_row_out[k];
            r[k] = v;
          }
          if (r.cols != null) {
            for (k in tp2_row_out) {
              v = tp2_row_out[k];
              r.cols[k] = v;
            }
          }
        }
      }
      tp2_out = data.tp2.run(data);
      for (k in tp2_out) {
        v = tp2_out[k];
        data[k] = v;
      }
      if (data.cols != null) {
        for (k in tp2_out) {
          v = tp2_out[k];
          data.cols[k] = v;
        }
      }
      return data;
    }

    generate(attach) {
      var all_subs, out, root_comp, root_part, template;
      root_comp = this.registry_get(this.name, []);
      this.data = this.run_fixes(root_comp, this.data);
      all_subs = root_comp.get_all_subs();
      root_part = root_comp.make_part(this, [], [], [], void 0);
      template = root_part.emit_template();
      template = template.wrap("<div></div>").parent();
      out = template.render(this.data, root_part.emit_directives());
      if (attach != null) {
        attach(out);
      }
      root_part.run_postproc(out, this.data);
      return out;
    }

    _read(path) {
      var data, i, k, len, ref;
      data = this.data;
      for (i = 0, len = path.length; i < len; i++) {
        k = path[i];
        data = (ref = data != null ? data[k] : void 0) != null ? ref : void 0;
      }
      return data;
    }

    _write(path, value) {
      var data;
      if (path.length) {
        data = this._read(path.slice(0, path.length - 1));
        if (data != null) {
          return data[path[path.length - 1]] = value;
        }
      } else {
        return this.data = value;
      }
    }

    registry_get(name, model_context) {
      var data, spec;
      data = this._read(model_context);
      [spec, data] = this.registry.get(name).run_preproc(data);
      this._write(model_context, data);
      return spec;
    }

  };

  Registry = class Registry {
    constructor(sets) {
      this.registry = {};
      this.register_sets(sets);
    }

    register_sets(sets) {
      var i, len, results, s;
      results = [];
      for (i = 0, len = sets.length; i < len; i++) {
        s = sets[i];
        results.push(this.register_all(s));
      }
      return results;
    }

    register_all(specs) {
      var k, results, v;
      results = [];
      for (k in specs) {
        v = specs[k];
        results.push(this.register(k, v));
      }
      return results;
    }

    register(name, spec) {
      return this.registry[name] = new Component(this, spec, name);
    }

    get(name) {
      if (this.registry[name] != null) {
        this.registry[name] = this.registry[name].resolved();
      }
      return this.registry[name];
    }

    generate(name, data, attach) {
      var a;
      a = new Assembly(this, name, data);
      return a.generate(attach);
    }

    config(name, key, data) {
      return this.get(name).get_config(key, data);
    }

  };

  window.Templates = Registry;

}).call(this);
