// Generated by CoffeeScript 2.3.1
(function() {
  // Copyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute
  // Copyright [2016-2018] EMBL-European Bioinformatics Institute

  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at

  //     http://www.apache.org/licenses/LICENSE-2.0

  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  // The table code exports two classes.

  // TableHolder -- the main class, one per table implemented here.

  // TableState  -- you subclass this and override methods and then supply it.
  //                  Contains callbacks whereby this code can record state
  //                  changes, eg column ordering, filtering, etc. and methods
  //                  to retrieve that info. Usually your implementation will
  //                  put these things in URLs, etc.

  //                  There is a getter/setter method in the superclass for
  //                  each piece of state, which you should leave alone.
  //                  Subclasses just override set() which should pull info
  //                  from these getters and then call their persistence layer.

  var Table, TableHolder, TableState, _clone_array;

  _clone_array = function(a) {
    return $.extend(true, [], a);
  };

  // XXX clear footer

  // XXX lowercase filter
  // XXX non-string comparison
  // XXX internal sort, filter etc
  // XXX delay search
  // XXX general ephemora
  TableState = class TableState {
    constructor(el, scols) {
      var c, j, len;
      this._filter = [];
      this._order = [];
      this._colkey = {};
      for (j = 0, len = scols.length; j < len; j++) {
        c = scols[j];
        this._colkey[c.key] = c;
      }
      this._sortkey = {};
      this.el = $(el);
      this.el.data('columns', (function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = scols.length; l < len1; l++) {
          c = scols[l];
          results.push(c.key);
        }
        return results;
      })());
      this.el.data('pagesize', 10);
      this.el.on('fix_widths', () => {
        var col, columns, i, l, len1, len2, len3, m, n, o, perc_per_unit, results, total, units_used;
        // convert widths to percentages
        columns = this.el.data('columns');
        for (l = 0, len1 = columns.length; l < len1; l++) {
          c = columns[l];
          if (this._colkey[c].width === 0) {
            this._colkey[c].width = 1;
          }
        }
        units_used = 0;
        for (m = 0, len2 = columns.length; m < len2; m++) {
          c = columns[m];
          units_used += this._colkey[c].width;
        }
        perc_per_unit = 100 / units_used;
        total = 0;
        for (n = 0, len3 = columns.length; n < len3; n++) {
          c = columns[n];
          this._colkey[c].total = this._colkey[c].width * perc_per_unit + total;
          total += this._colkey[c].width * perc_per_unit;
          this._colkey[c].percent = 0;
        }
        col = 0;
        results = [];
        for (i = o = 0; o <= 99; i = ++o) {
          if (i > this._colkey[columns[col]].total && col < columns.length) {
            col++;
          }
          results.push(this._colkey[columns[col]].percent++);
        }
        return results;
      });
    }

    e() {
      return this.el;
    }

    _update_sortkey() {
      var j, len, r, ref, results;
      this._sortkey = {};
      ref = this._order;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        r = ref[j];
        results.push(this._sortkey[r.column] = r.order);
      }
      return results;
    }

    filter(f) {
      (f != null ? this._filter = f : void 0);
      return this._filter;
    }

    columns() {
      return this.el.data('columns');
    }

    order(r) {
      if (r != null) {
        this._order = r;
        this._update_sortkey();
      }
      return this._order;
    }

    page(p) {
      var ref;
      (p != null ? this.el.data('page', p) : void 0);
      return (ref = this.el.data('page')) != null ? ref : 1;
    }

    pagesize() {
      if (this.pagesize_override) {
        return this.pagesize_override;
      } else {
        return this.el.data('pagesize');
      }
    }

    start() {
      return (this.page() - 1) * this.pagesize();
    }

    coldata() {
      var j, k, len, ref, results;
      ref = this.el.data('columns');
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        results.push(this._colkey[k]);
      }
      return results;
    }

    sortkey(k) {
      return this._sortkey[k];
    }

    associate(table1) {
      this.table = table1;
    }

  };

  TableHolder = class TableHolder {
    constructor(templates, state1, options = {}) {
      this.templates = templates;
      this.state = state1;
      this.options = options;
      this.state.associate(this);
      if (this.options.chunk_size == null) {
        this.options.chunk_size = 1000;
      }
    }

    // XXX abstract better
    transmit_data(el, fn, data) {
      var $form, c, j, l, len, len1, r, ref, ref1, row, rows;
      rows = [];
      rows.push(data.cols);
      ref = data.rows;
      for (j = 0, len = ref.length; j < len; j++) {
        r = ref[j];
        row = [];
        ref1 = data.cols;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          c = ref1[l];
          if (c === 'id_with_url') { // XXX ugly! Not General!
            r[c] = r['id'];
          }
          row.push(r[c]);
        }
        rows.push(row);
      }
      $form = $('.t_download_export', el);
      $('.filename', $form).val(fn);
      $('.data', $form).val(JSON.stringify(rows));
      $('.expopts', $form).val(JSON.stringify((function() {
        var len2, m, ref2, results;
        ref2 = data.cols;
        results = [];
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          c = ref2[m];
          results.push({});
        }
        return results;
      })()));
      return $form.trigger('submit');
    }

    // END used for download links
    collect_view_model(el, data) {
      return this.outer = el;
    }

    element() {
      return this.outer;
    }

    draw_table() {
      var table;
      table = new Table(this);
      return table.render();
    }

    xxx_table() {
      return new Table(this);
    }

    table_ready(html) {
      var table;
      table = $('.search_table_proper', this.outer);
      table.empty();
      return table.append(html);
    }

  };

  Table = (function() {
    var _idx;

    class Table {
      constructor(holder) {
        var ref;
        this.holder = holder;
        this.multisort = (ref = this.holder.options.multisort) != null ? ref : true;
      }

      render_head(t_data, data, first) {
        var c, dir, j, len, ref, state;
        t_data.headings = {};
        ref = this.holder.state.coldata();
        for (j = 0, len = ref.length; j < len; j++) {
          c = ref[j];
          state = 'off';
          dir = this.holder.state.sortkey(c.key);
          if (dir != null) {
            state = (dir > 0 ? "asc" : "desc");
          }
          if (c.nosort) {
            state = '';
          }
          t_data.headings[c.key] = {
            text: c != null ? c.name : void 0,
            state,
            key: c.key,
            dir
          };
        }
        return t_data.first = first;
      }

      render_row(data) {
        var klass;
        this.stripe = !this.stripe;
        klass = '';
        if (this.stripe) {
          klass = ' stripe';
        }
        if ((this.holder.options.style_col != null) && (data[this.holder.options.style_col] != null)) {
          klass += ' ' + data[this.holder.options.style_col];
        }
        return {
          cols: data,
          stripe: this.stripe,
          klass
        };
      }

      // XXX if top not moved then body not moved
      render_data(data, first) {
        var c, j, len, r, ref, t_data, t_main, table, widths;
        t_data = {
          table_row: [],
          rows: [],
          cols: data.cols
        };
        widths = (function() {
          var j, len, ref, results;
          ref = this.holder.state.coldata();
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            results.push(c.percent);
          }
          return results;
        }).call(this);
        t_data.widths = widths;
        if (first) {
          this.render_head(t_data, data, first);
        }
        ref = data.rows;
        for (j = 0, len = ref.length; j < len; j++) {
          r = ref[j];
          t_data.rows.push(this.render_row(r));
        }
        t_main = this.holder.templates.generate('chunk', t_data);
        // Bind events
        table = this;
        $('.search_table_sorter', t_main).on('click', function(e) {
          var dir, key, l, len1, order, ref1;
          order = [];
          key = $(this).data('key');
          dir = $(this).data('dir');
          if (e.shiftKey && table.multisort) {
            ref1 = this.holder.state.order();
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              e = ref1[l];
              if (e.column !== key) {
                order.push(e);
              }
            }
          }
          order.push({
            column: key,
            order: (dir > 0 ? -1 : 1)
          });
          table.holder.state.order(order);
          table.holder.state.set();
          return false;
        });
        return t_main;
      }

      render_chunk(data, first) {
        var d, outer;
        // Not async right now, but probably will be one day, so use deferred
        d = $.Deferred();
        outer = this.render_data(data, first);
        outer.appendTo(this.container);
        return d.resolve(data);
      }

      // XXX new
      reset() {
        if (this.container != null) {
          this.container.remove();
        }
        this.container = $('<div/>').addClass('search_table');
        this.stripe = 1;
        this.empty = 1;
        return this.holder.table_ready(this.container);
      }

      draw_top() {}

      draw_rows(rows) {
        var d;
        d = this.render_chunk(rows, this.empty); // XXX not false
        this.empty = 0;
        return d;
      }

      draw_bottom() {}

      // XXX done new
      render() {
        var chunk, page, start;
        if (this.container != null) {
          this.container.remove();
        }
        this.container = $('<div/>').addClass('search_table');
        this.stripe = 1;
        start = this.holder.state.start();
        page = this.holder.state.pagesize();
        chunk = this.holder.options.chunk_size;
        return this.get_page(page, start, chunk);
      }

    };

    _idx = 0;

    return Table;

  }).call(this);

  // XXX periodic headers
  window.TableState = TableState;

  window.search_table = TableHolder;

}).call(this);
