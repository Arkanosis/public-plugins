// Generated by CoffeeScript 1.5.0
(function() {
  var chunk_find, chunk_resize, chunk_size, create_table, deform, deformed, element, fixing, get_chunk, old_top, old_vpos, position_event, render_at, row_size, sizes, starts, tables, vpos;

  row_size = 10;

  starts = [];

  sizes = [];

  tables = [];

  chunk_size = 100;

  chunk_resize = function(chunk, size) {
    var delta, i, _i, _ref, _ref1, _results;
    delta = size - sizes[chunk];
    if (delta === 0) {
      return;
    }
    console.log("delta", chunk, delta, size, sizes[chunk]);
    sizes[chunk] = size;
    if (chunk < starts.length - 1) {
      _results = [];
      for (i = _i = _ref = chunk + 1, _ref1 = starts.length - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        _results.push(starts[i] += delta);
      }
      return _results;
    }
  };

  chunk_find = function(start) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = starts.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (start >= starts[i] && start < starts[i + 1]) {
        return i;
      }
    }
    if (start < starts[starts.length - 1] + sizes[starts.length - 1]) {
      return starts.length - 1;
    }
    console.log("overflow");
    return void 0;
  };

  get_chunk = function(chunk) {
    var i, _i, _results;
    console.log("get_chunk", chunk);
    _results = [];
    for (i = _i = 0; _i <= 99; i = ++_i) {
      _results.push([chunk, chunk + i, chunk * i, 'A', chunk * chunk * i]);
    }
    return _results;
  };

  create_table = function(data) {
    var col, row, table, td, tr, _i, _j, _len, _len1;
    table = $('<table></table').css('position', 'absolute');
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      row = data[_i];
      tr = $('<tr></tr>').appendTo(table);
      for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
        col = row[_j];
        td = $('<td></td>').appendTo(tr).text(col);
      }
    }
    return table;
  };

  old_vpos = void 0;

  vpos = void 0;

  element = void 0;

  deformed = void 0;

  old_top = void 0;

  fixing = 0;

  render_at = function(el, start, new_top) {
    var chunk, data, delta, new_height, offset, old_height, port_bottom, prev_bottom, ratio, resizes, row_start, t, table, table_bottom, table_height, toponscreen, total_height, _i, _len;
    old_height = starts[starts.length - 1] + sizes[starts.length - 1];
    port_bottom = $(window).scrollTop() + $(window).height() - el.offset().top;
    table_bottom = -1;
    for (_i = 0, _len = tables.length; _i < _len; _i++) {
      t = tables[_i];
      t.remove();
    }
    tables = [];
    console.log("start", start);
    chunk = chunk_find(start);
    if (chunk == null) {
      return;
    }
    row_start = start - chunk * chunk_size - 1;
    prev_bottom = $(window).scrollTop() - el.offset().top;
    delta = start - starts[chunk];
    resizes = {};
    while (table_bottom < port_bottom && chunk < starts.length) {
      console.log("chunk", chunk, starts.length);
      data = get_chunk(chunk);
      table = create_table(data);
      table.appendTo(el);
      toponscreen = $(window).scrollTop() - el.offset().top;
      if (toponscreen < 0) {
        toponscreen = 0;
      }
      offset = toponscreen - (start - starts[chunk]);
      console.log("we start / chunk start / toponscreen", start, starts[chunk], toponscreen, new_top - el.offset().top);
      table.css('top', offset + 'px');
      tables.push(table);
      table_height = table.outerHeight(true);
      table_bottom = table.position().top + table_height;
      resizes[chunk] = table_height;
      chunk_resize(chunk, table_height);
      chunk++;
      row_start = 0;
      prev_bottom = table_bottom;
      delta = 0;
    }
    total_height = starts[starts.length - 1] + sizes[starts.length - 1];
    console.log("total height", total_height);
    if (total_height !== old_height) {
      ratio = el.height() / old_height;
      new_height = ratio * total_height;
      console.log("box should be", old_height, new_height);
      el.height(new_height);
      deformed = total_height;
      if (old_vpos > vpos) {
        vpos += total_height - old_height;
      }
    }
    return old_vpos = vpos;
  };

  position_event = function() {
    var bottom, change, complete, dest, dheight, displayed, effective_bottom, effective_height, effective_range, incr, new_top, top;
    console.log("event", fixing);
    top = $(window).scrollTop();
    new_top = top;
    if (fixing) {
      old_top = top;
      fixing = 0;
      return;
    }
    bottom = top + $(window).height();
    dheight = element.outerHeight(true);
    effective_height = element.outerHeight(true) - $(window).height();
    effective_range = deformed - $(window).height();
    incr = (old_top != null) && (Math.abs(top - old_top) < $(window).height());
    change = top - old_top;
    old_top = top;
    console.log("bottom eot eoh", bottom, element.offset().top, element.outerHeight(true));
    effective_bottom = effective_height + element.offset().top;
    console.log("effective_height effective_range effective_bottom", effective_height, effective_range, effective_bottom);
    if (bottom > effective_bottom) {
      console.log("Effectively in bottom");
    }
    complete = element.offset().top < top && element.offset().top + element.outerHeight(true) > bottom;
    if (incr) {
      console.log("incr");
      vpos += change;
      if (vpos < 0) {
        vpos = 0;
      }
      if (vpos > deformed) {
        vpos = deformed;
      }
      dest = vpos * effective_height / effective_range + element.offset().top;
      fixing = 1;
      if (vpos !== 0 && vpos !== deformed) {
        new_top = dest;
      }
    } else {
      console.log("jump");
      displayed = top - element.offset().top;
      vpos = displayed * effective_range / effective_height;
      if (vpos < 0) {
        vpos = 0;
      }
      if (vpos > deformed) {
        vpos = deformed;
      }
    }
    console.log('vpos', vpos);
    if (top !== new_top) {
      $(window).scrollTop(new_top);
    }
    render_at(element, vpos, new_top);
    return true;
  };

  deform = function(region, amount) {
    element = region;
    deformed = amount;
    vpos = 0;
    $(window).scroll(function(e) {
      return position_event();
    });
    $(window).resize(function() {
      return position_event();
    });
    position_event();
    return $(window).keydown(function(e) {
      var bottom, sense, top;
      sense = 0;
      if (e.which === 33) {
        sense = -1;
      } else if (e.which === 34) {
        sense = 1;
      }
      if (sense !== 0) {
        top = $(window).scrollTop();
        top += sense * $(window).height() * 0.8;
        if (top < 0) {
          top = 0;
        }
        bottom = $(document).height() - $(window).height();
        if (top > bottom) {
          top = bottom;
        }
        $(window).scrollTop(top);
        return false;
      } else {
        return true;
      }
    });
  };

  $(function() {
    var el, i, max_chunk, rows, start, xxxstart, xxxy, _i, _ref;
    return;
    xxxy = 2000;
    xxxstart = 112;
    el = $('#deform').css('position', 'relative');
    if (!el.length) {
      return;
    }
    rows = 1000000;
    max_chunk = Math.floor((rows - 1) / chunk_size) + 1;
    console.log("max_chunk", max_chunk);
    start = 0;
    for (i = _i = 0, _ref = max_chunk - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      sizes[i] = row_size * chunk_size;
      starts[i] = start;
      start += row_size * chunk_size;
    }
    sizes[max_chunk - 1] = row_size * (rows - (max_chunk - 1) * chunk_size);
    deform(el, starts[starts.length - 1] + sizes[starts.length - 1]);
    $(window).keydown(function(e) {
      var chunk, sense;
      sense = 0;
      if (e.which === 65) {
        sense = -1;
      } else if (e.which === 66) {
        sense = 1;
      }
      if (sense !== 0) {
        xxxstart += sense;
        xxxy += sense * 23;
        chunk = chunk_find(xxxy);
        console.log("xxxy", xxxy, chunk);
        return false;
      } else {
        return true;
      }
    });
    return $(window).scrollTop(50088);
  });

}).call(this);
