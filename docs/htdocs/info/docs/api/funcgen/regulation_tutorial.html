<html>
<head>
<title>Ensembl Regulation (funcgen) API Tutorial</title>
</head>

<body>

<h1>Ensembl Regulation (funcgen) API Tutorial</h1>

<h2 id="introduction">Introduction</h2>

<p>
  The Ensembl Regulation team deals with functional genomics data. The API and databases for Ensembl Regulation are called Funcgen. 
</p>

<p>
  This tutorial is an introduction to the <a href="/info/docs/api/funcgen/index.html">Funcgen API</a>. Knowledge of the <a href="/info/docs/api/core/index.html">Ensembl Core API</a> and of the concepts and conventions in the <a href="/info/docs/api/core/core_tutorial.html">Ensembl Core API tutorial</a> is assumed. Please note that the Ensembl Core API must also be <a href="/info/docs/api/api_installation.html">installed</a> to use the Funcgen API.
</p>

<h2 id="connecting">Connecting to the funcgen Database using the Registry</h2>

<p>
Connecting to any Ensembl database is made simple by using the 
<kbd>Bio::EnsEMBL::Registry</kbd> module:
</p>

<pre class="code sh_perl">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;

Bio::EnsEMBL::Registry->load_registry_from_db(
    -host => 'ensembldb.ensembl.org',
    -user => 'anonymous'
);
</pre>

<p>
  The use of the registry ensures you will load the correct versions of the Ensembl databases
  for the software release it can find on a database instance. Using the registry object, 
  you can then create any of number of database adaptors. Each of these adaptors is 
  responsible for generating an object of one type. The above code will be omitted from the 
  following examples for brevity.
</p>

<h2 id="regulatory_features">Regulatory Features</h2>

<p>
Regulatory Features are features like involved with regulatory aspects like:
</p>

<ul>
  <li>Predicted promoters,</li>
  <li>Predicted promoter flanking regions,</li>
  <li>Predicted enhancer regions,</li>
  <li>CTCF Binding Sites,</li>
  <li>Transcription factor binding sites or</li>
  <li>Open chromatin regions.</li>
</ul>

<p>
  The are generated by the <a href="/info/genome/funcgen/index.html">Ensembl Regulatory Build</a>.
</p>

<p>
  To fetch Regulatory Features from the funcgen database, you need to use the corresponding adaptor. 
  To obtain all the regulatory features present in a given region of the genome, use the adaptor method 
  <kbd>fetch_all_by_Slice</kbd>:
</p>

<pre class="code sh_perl">

my $slice_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Core', 'Slice');
my $slice = $slice_adaptor->fetch_by_region('chromosome', 1, 54_960_000, 54_980_000);

my $regulatory_feature_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Funcgen', 'RegulatoryFeature');
my @regulatory_features = @{$regulatory_feature_adaptor->fetch_all_by_Slice($slice)};

foreach my $current_regulatory_feature (@regulatory_features) {
  print $current_regulatory_feature->stable_id.": ";
  print_feature($current_regulatory_feature);
  print "\tFeature Type: ".$current_regulatory_feature->feature_type->name."\n";
}

</pre>

<h2 id="regulatory_activities">Regulatory Activities</h2>

<p>
  For every regulatory feature the Ensembl Regulatory Build predicts the regulatory activity of the regulatory feature in each of the epigenomes of the regulatory build. For every epigenome there are 5 possible activities:
</p>

<ol>
  <li>Inactive,</li>
  <li>Repressed,</li>
  <li>Poised,</li>
  <li>Active or </li>
  <li>Na</li>
</ol>

<p>
  The regulatory activities have their own object and can be queried like this:
</p>

<pre class="code sh_perl">
  my $regulatory_feature_demo_stable_id = 'ENSR00000165384';

  my $regulatory_feature = $regulatory_feature_adaptor->fetch_by_stable_id($regulatory_feature_demo_stable_id);
  print "The regulatory feature with stable id: "  . $regulatory_feature->stable_id . " has the following activities: \n";

  my $regulatory_activity_adaptor = Bio::EnsEMBL::Registry->get_adaptor('homo_sapiens', 'funcgen', 'RegulatoryActivity');
  my $regulatory_activity_list    = $regulatory_activity_adaptor->fetch_all_by_RegulatoryFeature($regulatory_feature);

  foreach my $current_regulatory_activity (@$regulatory_activity_list) {
    print "\tIn the epigenome "  
      . $current_regulatory_activity->get_Epigenome->display_label 
      . ' it is: ' 
      . $current_regulatory_activity->activity 
      . "\n";

  }
</pre>

<h2 id="regulatory_activities">Regulatory Evidence</h2>

<p>
  The regulatory build can provide evidence to support its prediction. The regulatory evidence are motifs. This example is like the previous one, but for the regulatory activities that have regulatory evidence it prints this evidence:
</p>

<pre class="code sh_perl">
  my $regulatory_feature_demo_stable_id = 'ENSR00000165384';
  my $regulatory_feature = $regulatory_feature_adaptor->fetch_by_stable_id($regulatory_feature_demo_stable_id);

  print "The regulatory feature with stable id: "  . $regulatory_feature->stable_id . " has the following activities: \n";

  my $regulatory_activity_adaptor = Bio::EnsEMBL::Registry->get_adaptor('homo_sapiens', 'funcgen', 'RegulatoryActivity');
  my $regulatory_activity_list = $regulatory_activity_adaptor->fetch_all_by_RegulatoryFeature($regulatory_feature);

  my $regulatory_evidence_link_adaptor = Bio::EnsEMBL::Registry->get_adaptor('homo_sapiens', 'funcgen', 'RegulatoryEvidenceLink');

  foreach my $current_regulatory_activity (@$regulatory_activity_list) {

    print "\tIn the epigenome "  
      . $current_regulatory_activity->get_Epigenome->display_label 
      . ' it is: ' 
      . $current_regulatory_activity->activity 
      . "\n";

    my $regulatory_evidence_link_list = $regulatory_evidence_link_adaptor->fetch_all_by_RegulatoryActivity($current_regulatory_activity);

    if (@$regulatory_evidence_link_list) {
      print "  This is supported by the following evidence:\n";

      foreach my $current_regulatory_evidence_link (@$regulatory_evidence_link_list) {
        my $evidence = $current_regulatory_evidence_link->get_Evidence;
        print "  - " . $evidence->display_label . ': ' . $evidence->start . '..' . $evidence->end . "\n";
      }
    }
  }

</pre>

<h2 id="peaks">Peaks: Enriched regions from ChIP-seq and other high throughput experiments</h2>

<p>
Regulatory Features are built based on results from experiments like Dnase1 sensitivity assays (Dnase-Seq)
to detect regions of open chromatin, or transcription factor binding assays, like Chromatin immunoprecipitation (ChIP) 
coupled with high throughput sequencing (ChIP-Seq). Results from these experiments are stored as <code>Peaks</code>. 
</p>

<p>
ChIP-Seq studies are also used to detect histone modifications (eg. H3K36 trimethylation) and Polymerase binding sites.
</p>

<p>
  Peaks have these properties:
</p>

<ul>
  <li><code>Feature Type</code> usually representing antibody used in ChIP experiment.</li>
  <li><code>Feature Set</code> for this Peak (see further down in Tutorial).</li> 
  <li><code>Score</code>. An analysis-dependent value (eg. peak-caller score)</li>
  <li>The peak <code>Summit</code>. Precise 1bp position within the peak with the highest read density in a ChIP experiment. It is dependent on the analysis and sometimes it may not be present.</li> 
</ul>

<h2 id="peaks_fetch_by_Slice">Fetch all Peaks on a Slice</h2>

<p>
  Here is an example how peaks can be fetched from a <code>Slice</code> and printed with their properties:
</p>

<pre class="code sh_perl">
use strict;
use warnings;
use Bio::EnsEMBL::Registry;
use List::Util qw( min );

my $registry = 'Bio::EnsEMBL::Registry';

$registry->load_registry_from_db(
    -host => 'ensembldb.ensembl.org',
    -user => 'anonymous'
);

my $peak_adaptor  = Bio::EnsEMBL::Registry->get_adaptor('homo_sapiens', 'funcgen', 'Peak');
my $slice_adaptor = Bio::EnsEMBL::Registry->get_adaptor('homo_sapiens', 'core',    'Slice');

# Fetch a slice
my $slice = $slice_adaptor->fetch_by_region( 'chromosome', '17', 63_992_802, 64_038_237);

# Fetch all peaks on the slice
my $peaks_on_slice = $peak_adaptor->fetch_all_by_Slice($slice);

my $number_of_peaks_on_slice = @$peaks_on_slice;
print "There are $number_of_peaks_on_slice peaks on the slice.\n";

# Print the first ten
my $max_features_to_print = 10;

# This prints:
# 
# There are 697 peaks on the slice.
# H3K36me3 - Fetal Stomach Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K27me3 - EM CD8+ ab T cell (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K9me3 - CD14+CD16- monocyte (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K36me3 - H1-trophoblast Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K36me3 - naive B cell (To) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K36me3 - CD14+CD16- monocyte (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K36me3 - naive B cell (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K27me3 - neutrophil (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K27me3 - M2 macrophage (VB) Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
# H3K36me3 - Fetal Stomach Enriched Site (chromosome:GRCh37:17:63992802:64038237:1)
#
for my $i ( 1.. min($max_features_to_print, $number_of_peaks_on_slice) ) {
  print_feature($peaks_on_slice->[$i]);
}

sub print_feature {
  my $feature = shift;
  print 
    $feature->display_label
    . " (" 
    . $feature->slice->name 
    . ")\n";
}
</pre>

<h2 id="motif">Motif Features: Transcription factor binding sites</h2>

<p>
Motif Features represent short genomic regions where a Transcription Factor is 
thought to be directly interacting with the DNA. These regions are called Transcription Factor binding sites. More information on how these sites are found in Ensembl is
on the <a href="/info/genome/funcgen/index.html">RegulatoryBuild</a> page.
</p>

<p>
  To obtain the motif features present in a given Regulatory Feature, you can do this:
</p>

<pre class="code sh_perl">
  my $motif_features = $regulatory_activity->get_RegulatoryEvidence_by_type('motif');
</pre>
or
<pre class="code sh_perl">
  my $slice = $slice_adaptor->fetch_by_region('chromosome', 1, 54_960_000, 54_980_000);

  my $motif_feature_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Funcgen', 'MotifFeature');
  my $motif_features = $motif_feature_adaptor->fetch_all_by_Slice($slice);
</pre>

<p>
  Motif Feature objects have these properties:
</p>

<ul>
  <li><code>Binding Matrix</code>: Position Weight Matrix used to define the site. These are 
  currently from <a href="http://jaspar.genereg.net">Jaspar</a> and their name is the Jaspar Identifier.</li>
  <li><code>Score</code>. analysis-dependent value indicating degree of similarity to the binding matrix</li>
</ul>

<p>
  Here is an example how properties from motif features can be printed:
</p>

<pre class="code sh_perl">
foreach my $current_motif_feature (@$motif_features) {
  print_feature($current_motif_feature);
  print $current_motif_feature->binding_matrix->name . "\n";
  print $current_motif_feature->seq                  . "\n";
  print $current_motif_feature->score                . "\n";
  
}
</pre>

<h2 id="external">External Features: Externally curated data</h2>

<p>
There are some Feature Sets that are either entirely or partially curated by external groups. 
These are stored as External Features and can be accessed as follows:
</p>

<pre class="code sh_perl">
  # Fetch all external feature sets
  my $external_feature_sets = $feature_set_adaptor->fetch_all_by_feature_class('external');

  foreach my $current_external_feature_set (@$external_feature_sets) {
    print "External FeatureSet: " . $current_external_feature_set->name . "\n";
  }
</pre>

<p>
  If you know the name of a feature set, you can use the name to fetch the data. For example, we store data from the <a href="http://enhancer.lbl.gov">Vista Enhancer Browser</a>.
</p>

<pre class="code sh_perl">
  my $vista_feature_set = $feature_set_adaptor->fetch_by_name('VISTA enhancer set');

  # Now you can get all the features (in this case external features) 
  # You can also get features by Slice using get_Features_by_Slice: 
  #
  foreach my $current_vista_feature (@{$vista_feature_set->get_all_Features}){
      print_feature($current_vista_feature);
      
      # There is no epigenome for these features
      # Feature type indicates vista annotation (eg. active enhancer)
      #
      print $current_vista_feature->feature_type->name."\n";
  }
</pre>


<h2 id="featuretypes">Feature Types</h2>

<p>
Feature Types provide a biological annotation for features. They are divided in classes forming biologically 
coherent groups (eg. Transcription Factors). This is different from the Feature Set class, which just states 
the origin of the data. Feature Types can be accessed using a specific adaptor: 
</p>

<pre class="code sh_perl">
  my $feature_type_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Funcgen', 'FeatureType');
</pre>

<h3 id="extft">External Feature Types</h3>

<p>
Feature Types for External Features have a meaning that is specific to the Feature Set. For example, for features of the Vista 
Feature Set, the feature type indicates if the feature was active or inactive in an experiment.  
</p>

<h2 id="microarray">Microarrays and associated Information</h2>

<p>
This code demonstrates the use of adaptors, specifically the ArrayAdaptor. 
In this example, we export all microarray platforms and associated information.
</p>

<pre class="code sh_perl">
  # Grab the adaptor
  my $array_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human','Funcgen','Array');

  my $array = $array_adaptor->fetch_all;

  foreach my $current_array (@$array) {
  
    # Print some array info
    print "Array:  " . $current_array->name   ."\n";
    print "Type:   " . $current_array->type   ."\n";
    print "Vendor: " . $current_array->vendor ."\n";
    
    my $array_chips   = $current_array->get_ArrayChips;

    #Print some ArrayChip info
    foreach my $current_array_chip (@$array_chips) {
      print "ArrayChip: " 
        . $current_array_chip->name 
        . " DesignID: " 
        . $current_array_chip->design_id . "\n";
    }
    print "\n";
  }
</pre>

<h3 id="probesets">Fetch all ProbeSets from a specific Array</h3>

<p>
In this example, probesets from the WholeGenome_4x44k_v1 array are obtained.
</p>

<pre class="code sh_perl">
  my $probe_adaptor         = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Funcgen', 'Probe');
  my $probe_feature_adaptor = Bio::EnsEMBL::Registry->get_adaptor('Human', 'Funcgen', 'ProbeFeature'); 

  # Fetch a probeset from the WholeGenome_4x44k_v1 array
  my $probe = $probe_adaptor->fetch_by_array_probe_probeset_name('WholeGenome_4x44k_v1', 'A_23_P18656');
  print "Got " . $probe->class . " probe " . $probe->get_probename . "\n";

  # Fetch the feature associated with this probe
  my @pfeatures = @{$probe_feature_adaptor->fetch_all_by_Probe($probe)};
  print "\nFound ".scalar(@pfeatures)." ProbeFeatures\n";

  #Print some info about the features
  foreach my $pfeature ( @pfeatures ){
    print "\nProbeFeature found at:\t".$pfeature->feature_Slice->name."\n";
  }
</pre>

<h3 id="micannot">Microarray Annotations</h3>

<p>
  In this example, the FOXP2 transcript is fetched by it&apos;s stable_id. Then all ProbeSets that have been mapped to this transcript are fetched and printed.
</p>

<pre class="code sh_perl">
  #Grab the relevant adaptors
  my $transcript_adaptor = Bio::EnsEMBL::Registry->get_adaptor("human", "Core",    "Transcript");
  my $probe_set_adaptor  = Bio::EnsEMBL::Registry->get_adaptor("human", "Funcgen", "ProbeSet");

  #Fetch the transcript and associated ProbeSets
  my $transcript = $transcript_adaptor->fetch_by_stable_id('ENST00000393489');#Foxp2
  my $probesets  = $probe_set_adaptor->fetch_all_by_external_name($transcript->stable_id);

  foreach my $probeset (@$probesets) {

    my $arrays_string = join(', ', (map { $_->name } @{$probeset->get_all_Arrays}));

    # Now get linkage annotation
    #
    my $database_entry_info;
    foreach my $current_database_entry (@{$probeset->get_all_Transcript_DBEntries($transcript)}) {

      # This will return all ProbeSet DBEntries for this transcript
      # There should really be one max per transcript per probeset/probe
      #
      $database_entry_info = $current_database_entry->linkage_annotation;
    }
    print $probeset->name 
      . " on arrays " . $arrays_string 
      . " with Probe hits $database_entry_info\n";
  }
</pre>

<p>
Documentation on the current array mapping strategy can be found <a href="/info/genome/microarray_probe_set_mapping.html">here</a>.  
More examples for accessing microarray data can be found in the funcgen API package:
ensembl-funcgen/scripts/examples/microarray_annotation_example.pl
</p>

<h2 id="furtherhelp">Further help</h2>

<p>
Complete example scripts for the funcgen API can be found in the funcgen API package: ensembl-funcgen/scripts/examples/
For additional information or help mail the <a href="http://lists.ensembl.org/mailman/listinfo/dev" rel="external">ensembl-dev</a> mailing list. You will need to subscribe to this mailing list to use it.
More information on subscribing to any Ensembl mailing list is available from the <a href="/info/about/contact/">Ensembl Contacts</a> page.
</p>


</body>
</html>
